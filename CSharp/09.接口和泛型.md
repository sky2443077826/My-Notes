# 第九章 接口和泛型

- [第九章 接口和泛型](#第九章-接口和泛型)
  - [9.1 接口](#91-接口)
    - [9.1.1 什么是接口？](#911-什么是接口)
    - [9.1.2 接口的特性](#912-接口的特性)
    - [9.1.3 接口的使用](#913-接口的使用)
    - [9.1.4 接口的继承](#914-接口的继承)
    - [9.1.5 接口和抽象类](#915-接口和抽象类)
    - [9.1.6 练习](#916-练习)
  - [9.2 泛型](#92-泛型)
    - [9.2.1 什么是泛型](#921-什么是泛型)
    - [9.2.2 泛型的优点](#922-泛型的优点)
    - [9.2.3 泛型类型参数](#923-泛型类型参数)
    - [9.2.4 泛型方法](#924-泛型方法)
    - [9.2.5 泛型类](#925-泛型类)

## 9.1 接口
### 9.1.1 什么是接口？
接口是一组包含了类或结构**可以实现的功能**的定义。
由于C#只支持单继承，所以接口支持多实现的特性可以在一定程序上弥补该不 足。我们可以通过interface关键字定义接口:
```cs
interface IFly
{
    void Fly();
}
```

### 9.1.2 接口的特性
1. 接口是一个引用类型，只包含了功能的定义，不包含功能的实现
2. C#接口成员的访问级别是默认的（默认为public），**不可以使用其他修饰词修饰**
3. C#接口成员不能有static，abstract，override，virtual修饰
4. 接口一旦被实现，就**必须实现接口当中的所有成员**，除非实现类本身是抽象类
5. 接口**无法直接进行实例化**，因为其成员必须通过由实现接口的任何类或结构来实现
6. 接口可以包含事件，索引器，方法和属性，**但是不能包含字段。**
7. 类的继承只能单继承，**接口的实现支持多实现**

### 9.1.3 接口的使用
* 接口的定义：接口的声明使用interface关键字 
* 格式：访问修饰符 interface 接口名{	接口成员	}
* 例如
  ```cs
  public interface IFlyable
  {
    void Fly();
  }
  public interface ISpeak
  {
    void Speak();
  }
  ```
### 9.1.4 接口的继承
* 接口间的继承：
  * 接口可以像类一样继承，并且接口支持多继承。
  * 当接口A继承了接口B之后便拥有了接口B当中声明的方法。某个类实 现了接口A则必须实现接口A与接口B当中的所有方法。 
* 与类继承的差别：
  * 派生类继承了基类的方法的声明与实现，而派生接口只继承了父接口的成员方法声明。

### 9.1.5 接口和抽象类
接口与抽象类非常相似，它定义了一些未实现的属性和方法。所有继承它的类都继承这些成员，在这个角度上，可以把接口理解为一个类的模板。**接口最终的目的是起到统一的作用**。
* 相同点：
  1. 两者都不能被实例化
  2. 两者都包含了由其他类或结构继承或实现的抽象成员
* 不同点：
  1. 抽象类当中除了拥有抽象成员外还可以拥有非抽象成员；**而接口中所有的所有成员都是抽象的**
  2. 抽象成员**可以使用修饰符修饰**，接口当中接口成员访问级别是默认不可修改的，并且默认是public
  3. 接口当中**不可以包含构造方法，析构方法，静态成员以及常量**
  4. C#类只支持单继承，**接口支持多支持**

### 9.1.6 练习
```cs
class Program
    {
        static void Main(string[] args)
        {
            //定义接口IBattle，该接口包含功能Attack()，Move()， Jump()；
            //定义接口IRest，该接口包含功能SitDown()，Sleep()。
            //定义接 口IPlayer，接口IPlayer继承IBattle与IRest。
            //定义Soldier类实现IPlayer 接口

            Soldier soldier = new Soldier();
            soldier.Attack();
            soldier.Move();
            soldier.Jump();
            soldier.SitDown();
            soldier.Sleep();
            
        }
    }

 class Soldier : IPlayer
 {
     public void Attack()
     {
         Console.WriteLine("士兵正在攻击！");
     }

     public void Move()
     {
         Console.WriteLine("士兵正在移动！");
     }

     public void Jump()
     {
         Console.WriteLine("士兵正在跳跃！");
     }

     public void SitDown()
     {
         Console.WriteLine("士兵坐下！");
     }

     public void Sleep()
     {
         Console.WriteLine("士兵正在睡觉！");
     }
 }

 interface IBattle
 {
     void Attack();
     void Move();
     void Jump();
 }

 interface IRest
 {
     void SitDown();
     void Sleep();
 }

 interface IPlayer : IBattle, IRest
 { }
```

## 9.2 泛型
### 9.2.1 什么是泛型
我们在编写程序时经常遇到两个模块的功能非常相似，只是因为参数类型不同，所以分别写多个方法处理每种数据类型，因为方法的参数类型不同没法重用同样功能的代码。

C#中的**泛型能够将类型作为参数来传递**，即在创建类型时用一个特定 的符号如“T”来作为一个占位符，代替实际的类型，等待在实例化时 再用一个实际的类型来代替：
```cs
public static void Swap<T>(ref T value0,ref T value1)
{
    T temp = value0; 
    value0 = value1;	
}
```

### 9.2.2 泛型的优点
1. 使用泛型可以的重用代码，保护类型的安全以及提高性能
2. 降低强制转换或装箱操作的成本和风险
3. 可以对泛型参数进行限定以访问特定数据类型的方法

### 9.2.3 泛型类型参数
在泛型类型或方法定义中，类型参数是客户端在实例化泛型类型的变量时指定的特定类型的占位符。在上面例子泛型方法当中 **T** 即为泛型类型参数。

* 注意点：
  1. 泛型类型参数可以有多个
  2. 泛型类型参数可以是**编译器识别的任何数据类型**
  3. 泛型类型参数命名需要遵守命名规则
     * 使用描述性名称命名泛型类型，并且使用T作为前缀
     * 单个字母名称完全可以让人了解其表示的含义使用单个大写字母命名
* 约束
  * 在定义泛型类时，可以对客户端代码能够在实例化类时用于类型参数的类型种类施加限制。 如果客户端代码尝试使用某个约束所不允许的类型来实例化类，则会产生编译时错误。这些限制称为约束。**where关键字：在C#中对泛型类型参数的约束使用where上下文关键字。**  

* 泛型类型参数常用的约束类型
  1. **where T:struct**：表示泛型T是值类型(小数，整数，char，bool， struct)
  2. **where T:class**：表示泛型T是引用类型
  3. **where T:new()**：表示这个泛型具有一个无参数的构造方法,如果有 多个约束，new()必须放在最后
  1. **where T:基类名**：表示这个泛型是该基类或者其派生类
  2. **where T:接口名**：表示泛型是实现了该接口的类型

  * 注意⚠：
  可以对多个参数应用约束，也可以对同一参数进行多个约束。 例如：
      ```cs
      class Test<T, U> where U : struct where T : Base, new() {}
      ```
* 未绑定的类型参数
  1. 未绑定的类型参数是指那些没有约束的类型参数
  2. 不能使用!= 和 == 运算符，因为无法保证具体类型参数能支持这些 运算符
  3. 可以在它们与 System.Object 之间来回转换，或将它们显式转换为 任何接口类型
  4. 可以将它们与 null 进行比较。 将未绑定的参数与 null 进行比较时， 如果类型参数为值类型，则该比较将始终返回 false。

### 9.2.4 泛型方法
* 泛型方法是使用泛型类型参数声明的方法，当方法中存在某些参数的 类型不明确的时候就可以使用泛型方法。未知具体类型的参数就使用泛型类型参数替代。
* 格式： 访问修饰符 返回值类型 方法名<泛型类型参数>(参数列表){ 方法体}。
    ```cs
    public static string CombineToString<T>(T value1,T value2)
    { 
        return value1.ToString () + value2.ToString();
    }
    ```

### 9.2.5 泛型类
* 泛型类封装了不是特定于具体数据类型的操作，当类中存在未知参数 类型的时候就可以使用泛型类
* 格式：修饰符 class 类名 < 泛型类型参数 > { 类成员 }
  ```cs
  class BaseNodeGeneric<T> { }
  ```
* 实例化
  ```cs
  BaseNodeGeneric<int> bng0 = new BaseNodeGeneric<int> (); 
  BaseNodeGeneric<string> bng1 = new BaseNodeGeneric<string> ();
  ```
* 泛型类设计规则
  1. 将哪些类型通用化为泛型类型参数
  2. 如果存在约束，应对泛型类型参数应用什么约束
  3. 是否将泛型行为分解为基类和子类
  4. 是否实现一个或多个泛型接口
